---
title: "Redes neuronales"
author: "Angie Rodríguez Duque & César Saavedra Vanegas"
date: "Octubre 30 de 2020"
output:
  ioslides_presentation:
    widescreen: true 
    smaller: true 
    transition: slower
---

# REDES NEURONALES

##
Las redes neuronales artificiales son una representación abstracta del comportamiento de una red neuronal biológica. Su contexto se remonta a 1943, año en el cual McCulloch y Pitts proponen el primer modelo neuronal, dicho modelo era un modelo binario, en el cual cada neurona tenía un escalón o umbral prefijado. De esta manera sirvió de base para los modelos posteriores.

<center>
![Red neuronal](4.gif "Red neuronal"){width=500px}

## Capas

Las redes neuronales están compuestas por capas de neuronas que se comunican entre si y es posible dividirlas de la siguiente manera: 

<div class="columns-2">

- Capa de entrada
- Capa oculta
- Capa de salida

![Capas en redes neuronales](3.png "Red neuronal"){width=300px}
<div class="columns-2">

# ADAPTACIÓN DE REDES NEURONALES

## 

<center>
![Estructura](1.png "Red neuronal"){height=400px}

## Función base
<div style="text-align: justify">
**Función lineal de tipo hiperplano:** Es una función de base cuyo valor de red corresponde a una combinación lineal de las entradas.


$$u_{i}(w,x)=\sum_{j=1}^{n}w_{ij}x_{j}$$    


**Función radial de tipo hiperesférico:**

$$u_{i}(w,x)= \sqrt{\sum_{j=1}^{n}(x_{j}-w_{ij})^{2}}$$
<div/>
## Función de activación
<div style="text-align: justify">
Las funciones de activación se dividen en dos tipos como: lineal y no lineal

<center>
![Red neuronal](funciones.jpg "Regresión local"){width=500px}

<div/>

# ALGORITMO BACK PROPAGATION
##
<div style="text-align: justify">

1. Asignamos a cada conexión neuronal un peso con un valor pequeño, pero no nulo.

2. Introducimos la primera observación de nuestro conjunto de entrenamiento por la capa inicial de la red neuronal.

3. La información se propaga de izquierda a derecha, activando cada neurona que ahora es afectada por el peso de cada conexión, hasta llegar a la capa de neuronas de salida, obteniendo el resultado final para esa observación en concreto.

4. Medimos el error que hemos cometido para esa observación.

5. Comienza la propagación hacia atrás de derecha a izquierda, actualizando los pesos de cada conexión neuronal, dependiendo de la responsabilidad del peso actualizado en el error cometido.

6. Repetimos los pasos desde el paso 2, actualizando todos los pesos para cada observación o conjunto de observaciones de nuestro conjunto de entrenamiento.

7. Cuando todas las observaciones del conjunto de entrenamiento ha pasado por la red neuronal, hemos completado lo que se denomina un Epoch. Podemos realizar tantos Epochs como creamos convenientes.

<div/>

# ALGUNOS PROBLEMAS EN EL ENTRENAMIENTO DE LAS REDES NEURONALES
##
<div style="text-align: justify">

+ Valores iniciales: Se hace referencia a los valores que los pesos iniciales pueden tomar. Así, es recomendable llevar acabo una asignación de pesos pequeños generados de forma aleatoria.
+ Sobreajuste: La principales causas de los errores en los resultados de las redes neuronales se deben al sobreajuste de los datos
+ Escalado de las entradas:Respecto al escalado de las entradas se tiene que, resulta preferible estandarizar todas las entradas para que tengan una media de cero y una desviación estándar de uno.
+ Número de capas y unidades ocultas:El número de unidades ocultas está directamente relacionado con las capacidades de la red. Es decir para que el comportamiento de la red sea correcto.

<div/>

# APLICACIONES
##
<div style="text-align: justify">

La mayoría de las aplicaciones de las redes neuronales consisten en:

**Finanzas:** Previsión de la evolución de los precios, Valoración del riesgo de los créditos, Identificación de falsificaciones, Interpretación de firmas. 

**Manufacturación:** Robots automatizados y sistemas de control (visión artificial y sensores de presión, temperatura, gas, etc.), Inspección de la calidad. 

**Militares:** Clasificación de las señales de radar y Reconocimiento y seguimiento en el tiro al blanco. 

<div/>

# EJEMPLO DE APLICACIÓN
##
<div style="text-align: justify">

### **El conjunto de datos**

Se hará uso del conjunto de datos denominado: "Boston" perteneciente al paquete MASS. El conjunto de datos de Boston es una colección de datos sobre el valor de las viviendas en los suburbios de Boston. Nuestro objetivo es predecir el valor medio de las viviendas ocupadas por sus propietarios (medv) utilizando todas las demás variables continuas disponibles.

```{r warning=FALSE, include=T, paged.print=TRUE}
set.seed(500)
suppressMessages(library(MASS))
suppressMessages(library(neuralnet))
data <- Boston
```

Inicialmente se verifica que no falte ningún punto de datos; de lo contrario, es necesario corregir el conjunto.

```{r warning=FALSE, include=T, paged.print=TRUE}
apply(data,2,function(x) sum(is.na(x)))
```
<div/>

##

```{r warning=FALSE, include=T, paged.print=F}
index <- sample(1:nrow(data),round(0.75*nrow(data)))
train <- data[index,]
test <- data[-index,]
lm.fit <- glm(medv~., data=train)
pr.lm <- predict(lm.fit,test)
MSE.lm <- sum((pr.lm - test$medv)^2)/nrow(test)
```

##

```{r warning=FALSE, include=T, paged.print=F}
summary(lm.fit)

```



##

### **Adaptación de la red neuronal**

Antes de instalar una red neuronal, es necesario realizar algunos preparativos. Como primer paso, se aborda el preprocesamiento de datos. Aquí se normalizan los datos antes de entrenar la red neuronal.

Se elige el método min-max y se escalan los datos en el intervalo [0,1]. Normalmente, el escalado en los intervalos [0,1] o [-1,1] tiende a dar mejores resultados. Por lo tanto, escalamos y dividimos los datos antes de continuar:


```{r warning=FALSE, include=T, paged.print=TRUE}
maxs <- apply(data, 2, max) 
mins <- apply(data, 2, min)
scaled <- as.data.frame(scale(data, center = mins, scale = maxs - mins))
train_ <- scaled[index,]
test_ <- scaled[-index,]
```

+ **Nota:** Tener en cuenta que *scale* devuelve una matriz que necesita ser convertida en un data.frame.

## 

### **Parámetros**

<div style="text-align: justify">

En esta ocasión, vamos a utilizar 2 capas ocultas con esta configuración: 

$$13: 5: 3: 1$$

La capa de entrada tiene 13 entradas, las dos capas ocultas tienen 5 y 3 neuronas y la capa de salida tiene, por supuesto, una única salida ya que estamos haciendo regresión.

```{r warning=FALSE, include=T, paged.print=TRUE}
n <- names(train_)
f <- as.formula(paste("medv ~", paste(n[!n %in% "medv"], collapse = " + ")))
nn <- neuralnet(f,data=train_,hidden=c(5,3),linear.output=T)
plot(nn)
```

<div/>

## 

### **Representación gráfica**

<div style="text-align: justify">

El paquete neuralnet proporciona una buena herramienta para trazar el modelo. Esta es la representación gráfica del modelo con los pesos en cada conexión:

<center>
![Modelo red neuronal](5.png "Red neuronal"){width=900px}

<div/>


## 

### **Observaciones**

<div style="text-align: justify">

+ Las líneas negras muestran las conexiones entre cada capa y los pesos en cada conexión.

+ Las líneas azules muestran el término de sesgo agregado en cada paso.

+ El sesgo se puede pensar como la intersección de un modelo lineal.

+ Finalmente, el algoritmo de entrenamiento ha convergido y, por lo tanto, el modelo está listo para ser utilizado.

<div/>

## 

### **Predicción "medv" usando la red neuronal**

<div style="text-align: justify">

Ahora es posible predecir los valores para el conjunto de prueba y calcular el MSE.

<div/>

```{r warning=FALSE, include=T, paged.print=TRUE}
pr.nn <- compute(nn,test_[,1:13])

pr.nn_ <- pr.nn$net.result*(max(data$medv)-min(data$medv))+min(data$medv)
test.r <- (test_$medv)*(max(data$medv)-min(data$medv))+min(data$medv)

MSE.nn <- sum((test.r - pr.nn_)^2)/nrow(test_)
```

Se comparan los dos MSE para el modelo estimado de forma tradicional y por mediante la red neuronal:

```{r warning=FALSE, include=T, paged.print=TRUE}
print(paste(MSE.lm,MSE.nn))
```

Los resultados muestran que la red neuronal está realizando una mejor predicción para los "medv" que el modelo lineal.

##
### **Rendimiento de la Red neuronal vs. Modelo lineal**

<div style="text-align: justify">

A continuación se muestra un primer enfoque visual del rendimiento de la red y el modelo lineal en el conjunto de prueba.

<center>
![Real vs. predicción](salida1.png "Red neuronal"){width=500px}
<center>

<div style="text-align: justify">

A partir de la figura anterior es posible evidenciar que las predicciones hechas por la red neuronal están (en general) más concentradas alrededor de la línea (una alineación perfecta con la línea indicaría un MSE de 0 y, por lo tanto, una predicción perfecta ideal) que las realizadas por el modelo lineal.

<div>


##
### **Rendimiento de la Red neuronal vs. Modelo lineal**

<div style="text-align: justify">

A continuación se muestra una comparación visual más útil:

<center>
![Red neuronal real vs. predicción](salida2.png "Red neuronal"){width=500px}



<div>
